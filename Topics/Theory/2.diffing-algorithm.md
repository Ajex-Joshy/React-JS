# The Diffing Algorithm

- When diffing two trees, React first compares the two root elements. The behavior is different depending
  on the types of the root elements.

### Elements Of Different Types

- Whenever the root elements have different types, React will tear down the old tree and build the new
  tree from scratch.

- When tearing down a tree, old DOM nodes are destroyed. Component instances receive componentWillUnmount().
  When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive
  UNSAFE_componentWillMount() and then componentDidMount(). Any state associated with the old tree is lost.

- Any components below the root (child components) will also get unmounted and have their state destroyed

### DOM Elements Of The Same Type

- When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes.

### Recursing On Children

- By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference.

lets see one example

```html
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

here the React will match and only insert
` <li> third <li>`

but if we do this

```html
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

This will make the react to render the the whole component from begining as it renders whenever it founds a mismatch
This will result in worst performanc

In order to solve this issue, React supports a key attribute

### Keys

When children have keys, React uses the key to match children in the original tree with children in the subsequent tree.

```html
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

Now React knows that the element with key '2014' is the new one, and the elements with the keys '2015' and '2016' have just moved.

The key only has to be unique among its siblings, not globally unique.

As a last resort, you can pass an item’s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.
