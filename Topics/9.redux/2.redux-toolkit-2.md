### createAction, createReducer & builder

we can create actions separately using createActions and reducers using createReducers

lets see that

actually an actions is just a plain js object with type field and payload field (optional)
so to create an action manually (vannila redux) we will write

```js
export const addItem = (item) => {
  return {
    type: "cart/addItem",
    payload: item,
  };
};

export const removeItem = (itemId) => {
  return {
    type: "cart/removeItem",
    payload: { id: itemId },
  };
};

// This is known as action creators
```

An action creator in Redux is simply a function that creates and returns an action object that describes what happened in your app

Every time you need a new action, you’d manually write functions like this. That becomes repetitive.

we can simplify this using RTKs createAction, which generates action creators for you

```js
import { createAction } from "@reduxjs/toolkit";

export const addItem = createAction("cart/addItem");
export const removeItem = createAction("cart/removeItem");
```

now if you call

```js
addItem({ id: 1, name: "orange" });
removeItem({ id: 1 });
```

you will get

```js
{
  type: "cart/addItem",
  payload: { id: 1, name: "orange" }
}

{
  type: "cart/removeItem",
  payload: { id: 1 }
}
```

now we have created actions, lets create reducers

first lets create in vannila redux

```js
const initialState = {
  items: [],
};

function cartReducer(state = initialState, action) {
  switch (action.type) {
    case "cart/addItem":
      return {
        ...state,
        items: [...state.items, action.payload],
      };
    case "cart/removeItem":
      return {
        ...state,
        items: state.items.filter((item) => item.id !== action.payload.id),
      };
    default:
      return state;
  }
}

// Usage example (assuming you have a Redux store)
dispatch(addItem({ id: 1, name: "Apple", price: 50 }));
dispatch(addItem({ id: 2, name: "Orange", price: 30 }));
dispatch(removeItem(1)); // removes the item with id 1
```

In plain Redux we have to do like this
Problems:

- Verbose switch/case.
- Always need to copy state manually (immutability).

in RTK we have createReducer which is a helper functions that makes writing reducers easier and safer

- It eliminates the long switch statements
- It allow you to write mutating logic with help of immer

lets see how can we create reducers in RTK

```js
import { createReducer } from "@reduxjs/toolkit";

const initialState = {
  items: [],
};

const cartReducer = createReducer(initialState, (builder) => {
  builder
    .addCase(addItem, (state, action) => {
      state.items.push(action.payload);
    }) // either give action creator
    .addCase("cart/removeItem", (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload.id);
    }); // or action type string
});

export default cartReducer;

// With RTK and Immer, you can "mutate" state directly
```

### builder functions in reducer

When you use createReducer (or extraReducers in createSlice, we will see later), you pass in a callback function that receives a special object called builder.

This builder object provides methods for adding cases to the reducer in a clean, chainable way.
Instead of writing big objects or switch statements, you can register how your reducer should respond to actions using builder methods.

**Methods on builder**

**1. builder.addCase(actionCreatorOrType, reducer)**

- Defines how the reducer should handle a specific action.
- The first parameter can be either:
  - An action creator (created with createAction or createSlice), or
  - A string action type (e.g., "counter/increment").
- The second parameter is a reducer function (state, action) => {}.

**2. builder.addMatcher(matcherFn, reducer)**

- A matcher is just a function (action) => boolean.
- If it returns true, the reducer will run for that action.
- Useful when you want one reducer to handle multiple
  similar actions (like async request states).

```js
builder.addMatcher(
  (action) => action.type.endsWith("/pending"),
  (state, action) => {
    state.loading = true;
  }
);

builder.addMatcher(
  (action) => action.type.endsWith("/fulfilled"),
  (state, action) => {
    state.loading = false;
    state.data = action.payload;
  }
);
```

Here, any action that ends with /pending or /fulfilled will be handled, without writing separate addCase for each one.

**3. builder.addDefaultCase(reducer)**

- Defines a reducer that runs if no other addCase or addMatcher matches.
- Similar to the default: in a switch statement.

```js
builder.addDefaultCase((state, action) => {
  console.log("Unhandled action:", action.type);
});
```

lets recap

```js
// in vannila redux

// Action creators
const addItem = (item) => {
  return {
    type: "cart/addItem",
    payload: item,
  };
};

const removeItem = (itemId) => {
  return {
    type: "cart/removeItem",
    payload: { id: itemId },
  };
};

// Initial state
const initialState = {
  items: [],
};

// Reducer
function cartReducer(state = initialState, action) {
  switch (action.type) {
    case "cart/addItem":
      return {
        ...state,
        items: [...state.items, action.payload],
      };
    case "cart/removeItem":
      return {
        ...state,
        items: state.items.filter((item) => item.id !== action.payload.id),
      };
    default:
      return state;
  }
}

// Usage example
dispatch(addItem({ id: 1, name: "Apple", price: 50 }));
dispatch(removeItem(1));

// in RTK

import { createAction, createReducer } from "@reduxjs/toolkit";

// Actions
export const addItem = createAction("cart/addItem");
export const removeItem = createAction("cart/removeItem");

// Initial state
const initialState = {
  items: [],
};

// Reducer using createReducer
const cartReducer = createReducer(initialState, (builder) => {
  builder
    .addCase(addItem, (state, action) => {
      state.items.push(action.payload); // Immer allows direct "mutation"
    })
    .addCase(removeItem, (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload.id);
    });
});

export default cartReducer;

// Usage example
dispatch(addItem({ id: 1, name: "Apple", price: 50 }));
dispatch(removeItem({ id: 1 }));
```

In RTK we also have one more method ie createSlice which again makes it simplified by bundling the actions and reducers together without the need to write them separately

**createSlice -** Combines action creators and reducers in a single function. It’s the most convenient way to write Redux logic in RTK.

```js
import { createSlice } from "@reduxjs/toolkit";

const cartSlice = createSlice({
  name: "cart",
  initialState: { items: [] },
  reducers: {
    addItem: (state, action) => {
      state.items.push(action.payload);
    },
    removeItem: (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload.id);
    },
  },
});

export const { addItem, removeItem } = cartSlice.actions;
export default cartSlice.reducer;
```

- Automatically creates actions and reducers in one place.
- Generates action creators that match reducer function names.
- Simplifies boilerplate a lot compared to createAction + createReducer.
- Supports Immer for direct state mutation.

now if we our slice to respond to external action creators for eg-

- Actions from other slices
- Actions created with createAction
- Async actions created with createAsyncThunk (we will see later)

we can use a propery called **extraReducers** inside createSlice

```js
import { createSlice, createAction } from "@reduxjs/toolkit";

// 1. External action created with createAction
export const clearCart = createAction("cart/clearCart");

// 2. Cart slice
const cartSlice = createSlice({
  name: "cart",
  initialState: { items: [] },
  reducers: {
    addItem: (state, action) => {
      state.items.push(action.payload);
    },
    removeItem: (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload.id);
    },
  },
  extraReducers: (builder) => {
    // Handle the external  actions
    builder.addCase(clearCart, (state, action) => {
      state.items = []; // Clear all items in the cart
    });
  },
});

// Exporting the actions from slice
export const { addItem, removeItem } = cartSlice.actions;

// Export reducer
export default cartSlice.reducer;
```

here actually there is no need for writing clearCart as external actions but here I used it for demonstrating
the working of extraReducers

- Use reducers for slice-specific actions.
- Use extraReducers for external actions or async thunks.

