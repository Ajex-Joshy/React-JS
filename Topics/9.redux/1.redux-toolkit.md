### Redux

we all know what is a state. The main limitation of useState is that we can only declare local state variables. What if we could make a global state variable that we can access and update it from any where in our app. Thats exactly is redux.

**Redux is a pattern and library for managing and updating global application state, where the UI triggers events called "actions" to describe what happened, and separate update logic called "reducers" updates the state in response.** It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.

we will use the latest redux toolkit for writing redux logic

lets dive into architecture and concepts of redux

**1. Store**

- The store is the centralized container that holds the entire entire state of your application in a single javascript object tree
- There is only one store in redux application

**2. Slice**

- For each gobal state we will create each slice
- The slice will contain the state, actions, reducer functions etc
- We will create separate slices for each purposes inside our store
- So the store contains our multiple slices, for eg in an ecommerce application we will have a redux store for our app, inside the stor we will have userSlice which will contain the information about the logged in user, cart slice will contain the details of product which the user added to the cart.
- when our user logged in we will store the info in our userSlice and we will show it wherever we we need for eg in header like welcome user, in profile page and where ever we need we can access it

now lets move to the working of Redux.

In useState we can directly update a state but in redux its not like that. To update a state first we will dispactch an action this action will call a reducer function and this reducer function will update the state.

In use state we can acess the state directly but in redux its different. In redux We will subscribe to store and whenever the store change the UI it triggers the reconciliation.

now lets see how to

1. configure a store and provide to our app
2. create a slice
3. write actions and reducer functions
4. dispatch an action and subscribe to the store

before that lets install 2 packages @reduxjs/toolkit and react-redux

```
npm install @reduxjs/toolkit
focuses on creating and managing Redux state.

npm install react-redux
binding library between React and Redux.
useDispatch(), useSelector(), <Provider />
adapter that plugs Redux into React.
```

**1. Configuring store**

```js
import { configureStore } from "@reactjs/toolkit";

const appStore = configureStore({
  reducer: {},
});

export default appStore;
```

**2. Providing store to our app**

```js
import appStore from "src/store/appStore.js"
import { provider } from "react-redux"]
import App from "./App.js"
import { createRoot } from 'react-dom/client'

const root = createRoot(document.getElementById("root"))
root.render(
    <Provider store={appStore}>
        <App />
    </Provider>
    )

```

**3. Creating slice**
In a slice we will set name for the slice, initialState (initial value of the state), reducers (reducer funtions to update the state)
Then we will export the actions and reducers
also we need to provide the slice reducer to our store

Here for demonstration we will create a slice for storing data for cart items and we will set actions for
adding items to cart, removing items and clearing cart

```js
import { createSlice } from "@reactjs/toolkit";

const cartSlice = createSlice({
  name: "cart",
  initialState: {
    items: [],
  },
  reducers: {
    addItems: (state, action) => {
      state.items.push(action.payload);
    },
    removeItem: (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload);
    },
    clearCart: (state) => {
      state.items = [];
    },
  },
});

export const { addItems, removeItem, clearCart } = cartSlice.actions;

export default cartSlice.reducer;
```

here we have bundled the actions and reducers bundled together
we will see how to write actions and reducers separately in `redux-toolkit-2.md`

**Adding cart reducer to our store**

```js
import { configureStore } from "@reactjs/toolkit";
import cartReducer from "./cartSlice.js";

const appStore = configureStore({
  reducer: {
    cart: cartReducer,
  },
});

export default appStore;
```

**4. Dispatching actions**

for dispatching action we will use a hook given by
react-redux -useDispatch()

```js
import { addItems, removeItem, clearCart } from ".store/cartSlice.js";
import { useDispatch } from "react-redux";

export default function App() {
  const dispatch = useDispatch();
  const orange = { id: 1, item: "orange" };
  return (
    <div>
      <button onClick={dispatch(addItems(orange))}>Add Item</button>
      <button onClick={dispatch(removeItem(1))}>Remove Item</button>
      <button onClick={dispatch(clearCart())}>Clear Cart</button>
    </div>
  );
}
```

Here when we dispatch an action redux will
automatically call the corresponding reducer function
The parameter we are passing in the action will be passed in action.payload to reducer function

**5. Subscribing to the store**

To subscribe to the store we will use a hook given by
react redux - useSelector()

```js
import { useSelector } from "react-redux";

export default function App() {
  const items = useSelector((store) => store.cart.items);
  // we only need to subscribe cart. items in here
  // whenever the cart.items is updated our UI will be rerendered
  return (
    <div>
      <h1>No of items in the cart {items.length}</h1>
      <h4>items: {items} </h4>
    </div>
  );
}
```

### Points to note

updating immutability means that instead of directly changing the data structure. create a new copy and then update in the copy

**In JavaScript, "updating immutability" refers to creating a new version of a data structure with the desired changes, rather than directly modifying the original. This ensures the original data remains untouched.**

1. Spread Syntax (...) for Objects and Arrays
2. Array Methods that Return New Arrays

- map
- filter
- reduce
- slice
- concat

**React and Redux expect that all state updates are done immutably.**

**In Redux, our reducers are never allowed to mutate the original / current state values!**

**Reducers can only make copies of the original values, and then they can mutate the copies.**

but the Redux Toolkit's createSlice function allows you to write mutating logic

`createSlice` uses a library called **Immer** inside. Immer uses a special JS tool called a Proxy to wrap the data you provide, and lets you write code that "mutates" that wrapped data. But, Immer tracks all the changes you've tried to make, and then uses that list of changes to return a safely immutably updated value, as if you'd written all the immutable update logic by hand.

So effectively:

- You write mutable code (easy to understand).
- Immer applies changes immutably (ensuring Redux rules are followed).

so in redux tookit if you have to update a state

1. directly mutate the state and immer will hangle it
2. or return a copy of new state with desired change

**NB: be carefull while writing arrow functions, without curly brackets in arrow function, it will implicitly return and if we have written a mutating logic will cause error**

because here we are returning the mutating logic which is against the rule. we should only either mutate it or return new state

```js
const todosSlice = createSlice({
  name: "todos",
  initialState: [],
  reducers: {
    // ❌ ERROR: mutates state, but also returns new array size!
    brokenReducer: (state, action) => state.push(action.payload),
    // ✅ SAFE: the `void` keyword prevents a return value
    fixedReducer1: (state, action) => void state.push(action.payload),
    // ✅ SAFE: curly braces make this a function body and no return
    fixedReducer2: (state, action) => {
      state.push(action.payload);
    },
  },
});
```

**warning**
A common mistake is to try assigning `state = someValue` directly. This will not work! This only points the local state variable to a different reference. That is neither mutating the existing state object/array in memory, nor returning an entirely new value, so Immer does not make any actual changes.

```js
const initialState = [];
const todosSlice = createSlice({
  name: "todos",
  initialState,
  reducers: {
    brokenTodosLoadedReducer(state, action) {
      // ❌ ERROR: does not actually mutate or return anything new!
      state = action.payload;
    },
    fixedTodosLoadedReducer(state, action) {
      // ✅ CORRECT: returns a new value to replace the old one
      return action.payload;
    },
    correctResetTodosReducer(state, action) {
      // ✅ CORRECT: returns a new value to replace the old one
      return initialState;
    },
  },
});
```

### Rules of reducers

- They must be "pure" - they cannot do any asynchronous logic or other "side effects"
- They should only calculate the new state value based on the state and action arguments

The goal is to make our code predictable

### Advantages of RTK

- helps to avoid boiler plate code by using configureStore and createSlice apis
- immer, which helps to write mutating logic, it avoided many bugs while writing immutable updates andimproved the readability
