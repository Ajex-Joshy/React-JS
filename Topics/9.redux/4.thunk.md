### Thunk

**What is Redux Thunk?**
- Redux thunk is a middleware for redux.
- Its main purpose is to allow dispatching functions instead of plain objects as action
- This is essential for async operations like API calls, because redux can handle only synchronous actions 

**Problem Thunk Solves**
- you cannot perform async tasks directly in the actions like fetch api
- You’d have to do API calls outside Redux, then dispatch a plain action manually.

```js
store.dispatch({ type: "cart/fetchItems" }); 
// must be a plain object
```

but with thunk
- you can dispatch a function that performs async operations
- Inside that function, you can dispatch multiple plain actions (like pending, fulfilled, rejected) as needed.

```js
store.dispatch(asyncFunctionAction());
```

**How Redux Thunk Works**

- A thunk is simply a function returned from an action creator
- The Redux Thunk middleware intercepts this function, calls it, and passes the store's dispatch and getState methods as arguments.

```js
const fetchItems = () => {
  return async (dispatch, getState) => {
    // You can now do async work here
  };
};
```
- dispatch → lets you dispatch other actions.
- getState → lets you read the current state.

Middleware intercepts this function and executes it, giving access to dispatch and getState.

In vannila redux you have to install the package 
`npm install redux-thunk`

In RTK it comes out of the box, you dont have to mannually install it

lets see how we will do it redux

Reducer Handling Actions
```js
const initialState = { items: [], loading: false, error: null };

function cartReducer(state = initialState, action) {
  switch (action.type) {
    case "cart/fetchStart":
      return { ...state, loading: true, error: null };
    case "cart/fetchSuccess":
      return { ...state, loading: false, items: action.payload };
    case "cart/fetchError":
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}
```

Create Async Action (Thunk)
```js
// fetchItemsThunk.js
export const fetchItems = () => {
  return async (dispatch, getState) => {
    dispatch({ type: "cart/fetchStart" }); // start loading

    try {
      const response = await fetch("/api/items");
      const data = await response.json();
      dispatch({ type: "cart/fetchSuccess", payload: data });
    } catch (error) {
      dispatch({ type: "cart/fetchError", payload: error.message });
    }
  };
};
```

 Configure Store
```js
import { createStore, applyMiddleware } from "redux";
import thunk from "redux-thunk";
import cartReducer from "./cartReducer";

const store = createStore(cartReducer, 
    applyMiddleware(thunk)
);
```

Dispatch Thunk
```js
store.dispatch(fetchItems());
```

- Thunk allows dispatching a function instead of a plain object.
- That function can perform async operations and dispatch multiple actions.



### createAsyncThunk

in RTK the concept is same but the implementation is simpler
Redux Toolkit has thunk built-in, so you don’t need to install it manually.

createAsyncThunk is a helper in Redux Toolkit that lets you define async actions (thunks).

It automatically generates three action types for the lifecycle of a promise:

1. pending → when the async request starts
2. fulfilled → when the request succeeds
3. rejected → when the request fails

So you don’t need to manually dispatch start, success, error actions. It will be automatically dispatched createAsyncThunk and we only want to write reducers for this actions

```js

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const fetchItems = createAsyncThunk(
  "cart/fetchItems",
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch("/api/items");
      if (!response.ok) {
        // Force rejected case for HTTP errors
        throw new Error(`HTTP Error! Status: ${response.status}`);
      }
      const data = await response.json();
      return data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Slice
const cartSlice = createSlice({
  name: "cart",
  initialState: { items: [], loading: false, error: null },
  reducers: {
    addItem: (state, action) => {
      state.items.push(action.payload);
    },
    removeItem: (state, action) => {
      state.items = state.items.filter(item => item.id !== action.payload.id);
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchItems.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchItems.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchItems.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message; // comes from JS error
      });
  },
});

export const { addItem, removeItem } = cartSlice.actions;
export default cartSlice.reducer;

// Later, dispatch the thunk as needed in the app
dispatch(fetchItems)
```

createAsyncThunk("actionTypeString", payloadCreator)

**payloadCreator** is a callback function that return a promise containing the result of some asynchronous logic

if there is an error
- it should either return a rejected promise containing an Error instance
- or a resolved promise with a RejectWithValue argument returned by thunkAPI.rejectWithValue function.


The payloadCreator function will be called with two arguments:
1. arg 
    - a single value, containing the first parameter that was passed to the thunk action creator when it was dispatched.
    - useful when want to request api based on id. so we can pass the id as arg
    - if you have two pass multiple values, pass them together in an object


2. thunkAPI
    - an object containing all of the parameters that are normally passed to a Redux thunk
    - dispatch
    - getState
    - rejectWithValue(value)
    - fulfillWithValue(value)
    - etc..

**Return Value of createAsyncThunk**

- createAsyncThunk returns a standard Redux thunk action creator
- The thunk action creator function will have plain action creators for the pending, fulfilled, and rejected cases attached as nested fields.

`fetchCartItemById`, the thunk action creator that kicks off the async payload callback you wrote  
`fetchCartItemById.pending`, an action creator that dispatches a `'cart/fetchCartItemById/pending'` action  
`fetchCartItemById.fulfilled`, an action creator that dispatches a `'cart/fetchCartItemById/fulfilled'` action  
`fetchCartItemById.rejected`, an action creator that dispatches a `'cart/fetchCartItemById/rejected'` action

