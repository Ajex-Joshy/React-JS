In redux, the standard flow is:

1. you dispatch an action
2. The action goes to the reducers
3. Reducers update the state

This workes perfectly for synchronous updates.
also the reducers must be pure function => it cannot make any side effects like fetch api etc

what if you want to do something asychronous or need to add extra behaviour before reaching the reducer?

Redux reducers must be pure functions. This means:

- They must not have side effects (like making an API call).
- They must return the exact same output given the same input.

for eg when click a button you want to dispatch an action, it should fetch results from the api and update in store

as reducer is a pure function it cannot fetch any api

so before reaching the reducers we should fetch the result and give it to

so here comes the concept of

### Middleware

m
- Middleware is a function that sits between dispatching an action and reaching the reducer.
- It allows you to intercept actions, perform some operations, and then either:
  - Let the action pass to the reducer, or
  - Modify the action, or
  - Cancel it.

dispatch(action) --> middleware --> reducer --> state updated --> recconciliation triggered

Why do we need middleware?

 Redux by itself can only handle synchronous actions.
 Middleware helps with:
1. Logging actions and state (for debugging)
2. Async operations (like API calls)
3. Conditional actions (filter actions or add metadata)
4. Extending Redux with custom behavior


for eg:- 
- Logger middleware is a middleware that logs every action that is dispatched and the state before and after the action.
- It is mainly used for debugging and understanding state changes in Redux.

now lets see how we will write a middleware in vannila redux


A Redux middleware is basically a triple-arrow function:

```js
const middleware = store => next => action => {
  // Your code here
}
```
- store: Provides access to getState() and dispatch().
- next:  A function that dispatches the action to the next middleware in the chain, or to the reducer if it's the last middleware.

- action is the action being dispatched.

```js
// loggerMiddleware.js
const logger = (stostorereAPI) => (next) => (action) => {
  console.log("Dispatching action:", action);
  console.log("State before action:", store.getState());

  const result = next(action); // Pass the action to the next middleware or reducer

  console.log("State after action:", store.getState());
  return result;
};

export default logger;
```

To apply middleware to the store
```js
import { createStore, applyMiddleware } from "redux";
import cartReducer from "./cartReducer";
import logger from "./loggerMiddleware";

const store = createStore(cartReducer, applyMiddleware(logger));
```
dispatch some actions

```js
store.dispatch({ type: "cart/addItem", payload: { id: 1, name: "Apple" } });
store.dispatch({ type: "cart/removeItem", payload: { id: 1 } });
```

Console Output
```
Dispatching action: { type: "cart/addItem", payload: { id: 1, name: "Apple" } }
State before action: { items: [] }
State after action: { items: [{ id: 1, name: "Apple" }] }

Dispatching action: { type: "cart/removeItem", payload: { id: 1 } }
State before action: { items: [{ id: 1, name: "Apple" }] }
State after action: { items: [] }
```

1. storeAPI.getState() gives the current state before the action is applied.
2. next(action) passes the action to the reducer.
3. After next(action) executes, the state is updated.
4. Logger prints action, previous state, and next state.

dont want to study this, understand how middleware is used in vannila redux and how RTK has made it simplified

**Logger Middleware in Redux Toolkit (RTK)**

Redux Toolkit simplifies things, but the concept is the same. You just add it when configuring the store.

```js
const logger = (storeAPI) => (next) => (action) => {
  console.log("Dispatching action:", action);
  console.log("State before action:", storeAPI.getState());

  const result = next(action); // Pass action to reducers

  console.log("State after action:", storeAPI.getState());
  return result;
};
```

configure store with middleware

```js
import { configureStore } from "@reduxjs/toolkit";
import cartReducer from "./cartSlice";

const store = configureStore({
  reducer: {
    cart: cartReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger), // Add custom logger
});
```

Dispatch actions
```js
store.dispatch({ type: "cart/addItem", payload: { id: 1, name: "Orange" } });
store.dispatch({ type: "cart/removeItem", payload: { id: 1 } });
```

- getDefaultMiddleware() includes RTKâ€™s default middleware like redux-thunk.
- concat(logger) adds your custom logger middleware to the middleware chain.
- Logger works exactly like in vanilla Redux, logging action, previous state, and next state.
