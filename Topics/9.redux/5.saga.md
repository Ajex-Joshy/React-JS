### Redux-Saga

- Redux Saga is a middleware for Redux.
- it is used to handle side effects (async logic like API calls, delays, background tasks).
- It uses ES6 generator functions (function\*) which let you write async code that looks synchronous.
- Instead of writing async logic inside thunks, Saga moves it into separate “saga functions”, making them easier to test and reuse.

**Why Use Redux Saga?**

- Thunk is enough for basic API calls.
- Saga shines when you need:
- Cancelling async tasks (like aborting API calls if user leaves page)
- Debouncing / throttling (wait before firing API calls)
- Retrying failed requests
- Complex async flows (multi-step workflows)
- Running tasks in parallel or sequence

**Saga Flow**

```
dispatch(action)
   ↓
Saga Middleware intercepts
   ↓
Watcher Saga listens for the action
   ↓
Worker Saga runs side effect (API call, etc.)
   ↓
Worker Saga dispatches new action (success/error)
   ↓
Reducer updates state

```

**Basic Syntax**
A saga is just a generator function

```js
function* mySaga() {
  yield console.log("Saga is running");
}
```

lets see some special saga helpers that help us to run an action, call a function, dispatch an action etc..

- takeEvery(actionType, saga) → run saga on every action of that type
- takeLatest(actionType, saga) → run saga only for latest action, cancel previous
- call(fn, ...args) → call a function (usually async API calls)
- put(action) → dispatch an action
- all([...sagas]) → run multiple sagas in parallel

**Lets Fetch an api**

for that we have to install a package
`npm i redux-saga`

**1. Create slice**

```js
import { createSlice } from "@reduxjs/toolkit";

const cartSlice = createSlice({
  name: "cart",
  initialState: {
    items: null,
    loading: false,
    error: null,
  },
  reducers: {
    fetchItemsRequest: (state, action) => {
      state.loading = true;
    },
    fetchItemsSuccess: (state, action) => {
      state.loading = false;
      state.items = action.payload;
    },
    fetchItemsError: (state, action) => {
      state.loading = false;
      state.error = action.payload;
    },
    addItem: (state, action) => {
      state.items.push(action.payload);
    },
    removeItem: (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload.id);
    },
  },
});

export const {
  fetchItemsRequest,
  fetchItemsSuccess,
  fetchItemsError,
  addItem,
  removeItem,
} = cartSlice.actions;

export default cartSlice.reducer;
```

**2. create watcher and workder saga**

```js
import { takeEvery, call, put } from "redux-saga/effects";
import { fetchItemsSuccess, fetchItemsError } from "./cartSlice";

// worker saga
function* fetchItemsWorker() {
  try {
    const response = yield call(fetch, "/api/items"); // async call
    const data = yield response.json();
    yield put(fetchItemsSuccess(data)); // dispatch sucess (action creator - recommended. we can also give action type string)
  } catch (err) {
    yield put(fetchItemsError(err.message));
  }
}

// watcher saga
export function* watchFetchItems() {
  yield takeEvery("cart/fetchItemsRequest", fetchItemsWorker);
}
```

**3. create a root saga**

```js
import { all } from "redux-saga/effects";

function* rootSaga() {
  yield all([watchFetchItems()]);
}

export default rootSaga;
```

**4. Configure Store with Saga**

```js
import { configureStore } from "@reduxjs/toolkit";
import cartReducers from "./cartSlice.js";
import createSagaMiddleware from "redux-saga";
import rootSaga from "./rootSaga.js";

const sagaMiddleware = createSagaMiddleware();

const store = configureStore({
  reducer: {
    cart: cartReducers,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({ thunk: false }).concat(sagaMiddleware),
});

sagaMiddleware.run(rootSaga);

export default store;
```

We disabled thunk in getDefaultMiddleware since Saga is handling async now.

**Dispatch actions**

```js
import { fetchItemsRequest } from "redux/cartSlice.js";

// somewhere is your component
dispatch(fetchItemsRequest()); // Saga will catch this and run fetchItemsSaga
```

Dispatch action → Saga middleware intercepts → Watcher runs Worker → Side effects happen → New actions dispatched → Reducer updates state → UI updates.

- One big benefit of Sagas can be cancelled automatically (e.g., takeLatest cancels old API calls). This is something Thunk cannot do easily.

- Behind the scenes, Saga relies on generator functions and effect creators to make async code structured, testable, and cancellable.
